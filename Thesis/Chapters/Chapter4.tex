% !TEX root = ../main.tex

\chapter{Numerical methods} % Main chapter title
\label{Chapter4}

In this chapter will will develop the necessary method to compute the necessary coefficients to compute the gain/loss factor, using Mathematica\texttrademark.
We will go beyond the spherical approximation and calculate the SWSHs eigenvalues for any BH angular momentum.
With the eigenvalue defined for a particular mode, we will compute the asymptotic radial coefficients, which in turn are used to compute the amplification factor in three diferent ways.

\section{Eigenvalues}

The need for obtaining the eigenvalues $\uu[s]{\mathscr{E}}{\ell m}$ rests on the dependency to solve the radial equation numerically with no spherical approximation.
Additionally, the relative normalization constant $\mathscr{B}$, which depends explicitly on the eigenvalue, will be rather important in one the methods used to calculate the gain/loss factor $\uu[s]{Z}{\ell m}$ for each mode $(\omega,\ell,m)$.
There is no reason to differentiate the eigenvalue for given BH angular momentum and a particular frequency, since the parameter dependence of the eigenvalue is $c=a\omega$.
Considering the focus in superradiant modes, we only will need eigenvalues of coupling which is in the range $0<c<3$. 
Even for extremal BHs, the typical frequency value for a superradiant mode, $\bar{\omega}\sim 1/2$, so this margin is sufficient even for observing the effects in non-superradiant modes.
Due to symmetries XXXXX, instead of computing for negative values of $c$, we will consider all integer azimuthal numbers $|m|\le \ell$.

\subsection{Leaver method}

The first method implemented was Leaver's.
Consists is using the three recursion relation obtained for SWSHs and correspondent continued fraction~\eref{eq3:evInversion0th} and it's inversions.
Since the problem is now numerical, we have to stop the continued fraction at some particular $p=N$.
By substitution of the parameters $s$ and $m$ and $c$, we are left with an equation with $N$ roots for $\uu[s]{\mathscr{A}}{\ell m}$.
A root-finding algorithm is a method that allows to approximate roots of some equation $f(x)=0$, by suggestion of a connected region were $f$ has different signs at the boundary.
The method ``FindRoot'' in Mathematica\texttrademark~ allows to distinguish the roots of equation by finding the closest to a particular input value.
Firstly, we use the the expansion coefficients for $c\ll 1$~(\aref{AppendixEigenvalues}) to suggest a value of the eigenvalue $\uu[s]{\mathscr{E}}{\ell m}$ that is close to $\ell(\ell+1)$.
We improved on this method by starting the curve at $c=0$, and then obtaining the eigenvalue numerically for small increments in $c$ and then using the last eigenvalue solution as the initial guess for the next increment.
This is particularly useful to generate and save a complete table of eigenvalues for given range and then use interpolation methods to guess eigenvalues for intermediate $c$ values.

For both methods the obtained curves are well behaved for $\ell=1$, but for bigger $\ell$ we start to observe some discontinuities, especially when we increase the range of $c$.
For a fixed $s$ and $m$, we have an infinite number of curves labeled by $\ell$ and in some cases the root finding algorithm selecting roots from adjacent curves, either from the branch $\ell-1$ or $\ell+1$.
These solutions cannot ever intersect, otherwise the eigenvalue would be degenerate and the SWSHs would not be a orthogonal basis of functions.
The issue rests on the lack of accuracy when identifying of the $\ell$-th root.
We lose accuracy when trying to obtaining roots on levels further down in the continued fraction.
We solve the problem by considering the inversion~\eref{eq3:evInversionRth}, choosing $r=\ell+\max\{|m|,|s|\}$, as the main information in the value taken by the $\ell$-th root is in the $\beta_r$, with the fractions providing higher order contributions in $c$.

Once the eigenvalue root is know, one can find any number of the series expansions coefficients $a_p$, for a particular eigenfunction~\eref{eq3:SWSHseriesLeaver}, by using the three-coefficient recursion relation~\eref{eq3:ap3CoefRecursion}.

\subsection{Spectral method}

Due to initial problems with the Leaver method, we decided to use the spectral method.
Because the spheroidal~\eqref{eq3:teukolskyAngular} can be seen as a perturbed version of the spherical case, $c=0$.
We may rewrite the equation using three operators depending on their order in $c$, 
\begin{align}
	\label{eq4:angularEqH012}
	( \mathscr{H}^{(0)} +  \mathscr{H}^{(1)} + \mathscr{H}^{(2)} ) \uu[s]{S}{\ell m} = - \uu[s]{\mathscr{E}}{\ell m}  \;\uu[s]{S}{\ell m} 
\end{align}
The zeroth order operator $\mathscr{H}^{(0)}$, defines the eigenvalue problem for the spin-weighted spherical harmonics, which will provide the complete non-perturbed basis, $\mathscr{H}^{(0)} \,\uu[s]{Y}{\ell m} = -\ell(\ell+1) \,\uu[s]{Y}{\ell m}$.
The other two operators are quickly identified from the angular equation as $\mathscr{H}^{(1)} = - 2 s c \cos\theta$ and $\mathscr{H}^{(2)} = c^2 \cos^2\theta$.
Simple perturbation theory states that
\begin{align}
	\uu[s]{\mathscr{E}}{\ell m} &= \ell(\ell+1) - \int \dd\Omega \,(\uu[s]{Y}{\ell m})^* \,\mathscr{H}^{(1)} \,\uu[s]{Y}{\ell m} + \mathscr{O}(c^2) ~, \\
	\uu[s]{S}{\ell m} &= \uu[s]{Y}{\ell m} - \sum_{j\ne\ell} \frac{\int \dd\Omega \,(\uu[s]{Y}{j m})^* \,\mathscr{H}^{(1)} \,\uu[s]{Y}{\ell m}}{j(j+1)-\ell(\ell+1)} \, \uu[s]{Y}{j m} +\mathscr{O}(c^2) ~.
\end{align}
We may include $\mathscr{H}^{(2)}$ by using a higher order expansion, which can be found in any Quantum Mechanics textbook.
The integral $\int \dd\Omega \,(\uu[s]{Y}{j m})^* \,\mathscr{H}^{(1)} \,\uu[s]{Y}{\ell m}$ may be computed using Clebsch-Gordon coefficients decomposition generalized for spin-weighted functions, which is proportional to Leaver series coefficient $f_1$ defined in~\aref{AppendixEigenvalues}.
These operator are generally represented in the basis of spin-weighted spherical harmonics using
\begin{align}
	\begin{split}
	h^{(1)}_{j\ell} &= \int \dd\Omega \,\cos\theta \,(\uu[s]{Y}{j m})^* \,\uu[s]{Y}{\ell m} = \sqrt{\frac{2 \ell+1}{2 j+1}} \langle \ell,m; 1,0 | j,m \rangle \langle \ell, -s; 1,0 | j, -s \rangle ~, \\
	h^{(2)}_{j\ell} &= \int \dd\Omega \,\cos^2\theta \,(\uu[s]{Y}{j m})^* \,\uu[s]{Y}{\ell m} = \frac{\delta_{j\ell}}{3} + \frac{2}{3}\sqrt{\frac{2 \ell+1}{2 j+1}} \langle \ell,m; 2,0 | j,m \rangle \langle \ell, -s; 2,0 | j, -s \rangle ~.
	\end{split}
\end{align}

Perturbation theory shows that the SWSHs can be expanded in the basis of spherical harmonics.
This should not be a surprising fact as any angular function $f(\theta,\varphi)$ with a particular spin-weight $s$, can be represented using a decomposition using spin-weighted spherical harmonics.
Having this idea in mind, we write 
\begin{align}
	e^{i m \varphi} \, \uu[s]{S}{\ell m}(c; \theta) = \sum_{j} b_{j}^{(\ell)}(c) \,\uu[s]{Y}{j m}(\theta,\varphi) \qquad \Big( \ell, j \ge \max\{|s|,|m|\} \Big) ~.
\end{align}
Replacing the expansion in~\eqref{eq4:angularEqH012}, we can take advantage of the orthogonality of the harmonics, $\int \dd\Omega \,(\uu[s]{Y}{j m})^* \,\uu[s]{Y}{\ell m} = \delta_{\ell j}$, by multiplying the the equation by $(\uu[s]{Y}{\ell m})^*$ and integrating the solid angle.
The angular equation is replaced by an eigenvalue matrix equation $\sum_{j} a_{ij} \, b_{j}^{(\ell)} = - \uu[s]{\mathscr{E}}{\ell m} \,b_{i}^{(\ell)}$, such that
\begin{equation}
	a_{ij} =
	\begin{cases} 
		~c^2 \,h^{(2)}_{ii} - 2 c s \,h^{(1)}_{ii} - i(i+1) & ~ i=j \\[-0.5ex]
		~c^2 \,h^{(2)}_{ij} - 2 c s \,h^{(1)}_{ij} & ~ |i-j|=1 \\[-0.5ex]
		~c^2 \,h^{(2)}_{ij} & ~ |i-j|=2 \\[-0.5ex]
		~0 & ~\text{otherwise}
	\end{cases}  \qquad \Big( i, j \ge \max\{|s|,|m|\} \Big) ~,
\end{equation}
where the the eigenvalues of this matrix are $-\uu[s]{\mathscr{E}}{\ell m}$ and the correspondent eigenvector is given by $b_j^{(\ell)}$.

The matrix $[a_{ij}]$ is band-diagonal, optimized numerical methods allow for fast computation of the problem.
Like the Leaver method, we will have to truncate the matrix at some point.
Analyzing the matrix, we know that the larger contribution for the eigenvalue will be the element $a_{\ell\ell}$.
So the best way to approximate $\uu[s]{\mathscr{E}}{\ell m}$ would be to take a square submatrix so that $a_{\ell\ell}$ is centered and on the diagonal.
Since will will not take large $\ell$ values, we opted to implement a $N\times N$ matrix such that $i,j\ge\max\{|s|,|m|\}$ and truncating the matrix at a $i_{\max} = \ell - \max\{|s|,|m|\} + 1 + n_{c}$.
The integer $n_c \ge 5$ is a offset that adds extra elements to the matrix to address the increase of $c$.
We need 


\section{Radial equation}

\section{Amplification factor as as first test}

\section{MATHEMATICA CELLS}

Input from question with output from my Mathematica version.
Input is in input form, it can be copied and pasted to Mathematica.
\begin{mmaCell}[functionlocal=y,yoffset=3.5ex]{Code}
  Integrate[{y^(-3)*(1-(a/y)^2)^(-2)},{y,r,Infinity}]
\end{mmaCell}
\begin{mmaCell}{Output}
  \{ConditionalExpression[-\mmaFrac{1}{2 (\mmaSup{a}{2} - \mmaSup{r}{2})},
     Im[r] Re[a] ≠ Im[a] Re[r] || ((a + r > 0 || a + r ∉ Reals) &&
       ((Re[a] < r && Im[a] == 0) || a - r ∉ Reals)) || r ∉ Reals]\}
\end{mmaCell}

For comparison, same cells obtained by including PDFs exported from Mathematica:
% You need inCell.pdf and outCell.pdf files for this to work.
% \mmaCellGraphics{Input}{inCell}
% \mmaCellGraphics[yoffset=3.5ex]{Output}{outCell}

Same input expression, but in standard form (as if it was inputted using math assistant). Note that syntax coloring still works.
\begin{mmaCell}[index=3,functionlocal=y]{Input}
  \mmaSubSupM{\int}{r}{∞}\{\mmaFrac{1}{\mmaSup{y}{3}\mmaSup{\big(1-\mmaSup{\big(\mmaFrac{a}{y}\big)}{2}\big)}{2}}\}𝕕y
\end{mmaCell}


More features:
\begin{mmaCell}[
  moredefined=f,
  functionlocal=a,
  local=b,
  pattern={x_,x},
  excessargument=n,
  linkbuiltin=List
]{Code}
  (* A (* nested *) comment. *)
  Block[{a=3},a+2]
  f[x_]:=2x+1 
  Module[{b=c},
      Print["a string \" with double quotes inside ", b/d];
      b+1
  ]
  f[z]//FullForm
  Sin[m,n]
  List[1,List[2,3]]; (* Links to documentation. *)
\end{mmaCell}
\begin{mmaCell}{Output}
  5
\end{mmaCell}
\begin{mmaCell}{Code}
  a string " with double quotes inside \mmaFrac{c}{d}
\end{mmaCell}
\begin{mmaCell}[addtoindex=1]{Output}
  1+c
\end{mmaCell}
\begin{mmaCell}[form=FullForm]{Output}
  Plus[1,Times[2,z]]
\end{mmaCell}
\begin{mmaCell}[messagelink={message/General/argx}]{Message}
  Sin::argx: Sin called with 2 arguments; 1 argument is expected. >>
\end{mmaCell}
\begin{mmaCell}{Output}
  Sin[m,n]
\end{mmaCell}
\begin{mmaCell}{Output}
  \{1,\{2,3\}\}
\end{mmaCell}
Graphics mixed with code:
\begin{mmaCell}{Code}
  a=Graphics[{Green,Disk[]},ImageSize->50]/2
\end{mmaCell}
% You need greenDisk.pdf file for this to work.
% \begin{mmaCell}[moregraphics={moreig={scale=.7}}]{Output}
%   \mmaFrac{a \mmaGraphics{greenDisk}}{2}
% \end{mmaCell}
\begin{mmaCell}{Code}
  (* Different roles of one symbol. *)
  x;
  _x;
  \mmaDef{x_};
  \mmaPat{x_}->2x;
  \mmaPat{x_}:>2\mmaPat{x};
  f[\mmaPat{x_}]=2x;
  f[\mmaPat{x_}]:=2\mmaPat{x};
  Block[{\mmaFnc{x}},2\mmaFnc{x}];
  Module[{\mmaLoc{x}},2\mmaLoc{x}];
  \mmaUnd{Module}; (* undefined Module symbol *)
  \mmaLnB{Module}; (* Module symbol with link to documentation *)
  Sin[x\mmaExc{,x}];
\end{mmaCell}
\begin{mmaCell}[addtoindex=11]{Input}
  (* Nesting of "formatting boxes" *)
  \mmaSup{a}{\mmaSup{a}{a}} \mmaSub{a}{\mmaSub{a}{a}} \mmaSubSup{a}{\mmaSubSup{a}{a}{a}}{\mmaSubSup{a}{a}{a}} \mmaUnder{a}{\mmaUnder{a}{a}} \mmaOver{a}{\mmaOver{a}{a}} \mmaUnderOver{a}{\mmaUnderOver{a}{a}{a}}{\mmaUnderOver{a}{a}{a}} \mmaFrac{a}{\mmaFrac{a}{\mmaFrac{a}{a}}} \mmaSqrt{\mmaSqrt{a}} \mmaRadical{a}{\mmaRadical{a}{a}}
\end{mmaCell}
\begin{mmaCell}{Input}
  (* Replacements for infix operators in "Input" cells. *)
  x>=y; x<=y; x!=y; x->y; x:>y;
\end{mmaCell}
\begin{mmaCell}{Code}
  (* No replacement in "Code" cells. *)
  x>=y; x<=y; x!=y; x->y; x:>y;
\end{mmaCell}
\begin{mmaCell}[label={}]{Code}
  (* Cell with custom label. *)
\end{mmaCell}
\begin{mmaCell}{Input}
  \mmaLnT{x}=2;(* labeled definition of x *)
\end{mmaCell}
\begin{mmaCell}{Input}
  \mmaLnL{x}(* usage of x with link to its definition *)
\end{mmaCell}

Implemented syntax elements:
\begin{mmaCell}[
  defined=defined,
  undefined=undefined,
  functionlocal=functionlocal,
  local=local,
  pattern=pattern,
  localconflict=localconflict,
  globalconflict=globalconflict,
  excessargument=excessargument,
  unknownoption=unknownoption,
  unwantedassignment=unwantedassignment,
  shadowing=shadowing,
  syntaxerror=syntaxerror,
  emphasizedsyntaxerror=emphasizedsyntaxerror,
  formattingerror=formattingerror,
]{Code}
  \mmaDef{Def} defined (*  defined symbol *)
  \mmaUnd{Und} undefined (* UndefinedSymbol *)
  \mmaFnc{Fnc} functionlocal (* FunctionLocalVariable *)
  \mmaLoc{Loc} local (* LocalVariable *)
  \mmaPat{Pat} pattern (* PatternVariable *)
  \mmaLCn{LCn} localconflict (* LocalScopeConflict *)
  \mmaGCn{GCn} globalconflict (* GlobalToLocalScopeConflict *)
  \mmaExc{Exc} excessargument (* ExcessArgument *)
  \mmaOpt{Opt} unknownoption (* UnknownOption *)
  \mmaAsg{Asg} unwantedassignment (* UnwantedAssignment *)
  \mmaShd{Shd} shadowing (* SymbolShadowing *)
  \mmaSnt{Snt} syntaxerror (* SyntaxError *)
  \mmaEmp{Emp} emphasizedsyntaxerror (* EmphasizedSyntaxError *)
  \mmaFmt{Fmt} formattingerror (* FormattingError *)
\end{mmaCell}

Inline cell: \mmaInlineCell[functionlocal=a]{Code}{Module[{a=5}, a]}.
Formatted inline cell:
\mmaInlineCell[pattern={x_,x}]{Input}{f[x_]:=\mmaFrac{\mmaSup{x}{2}}{5}}
\subsubsection*{
  Inline cell inside macro argument:
  \mmaInlineCellNonVerb[functionlocal=x]{Code}{Solve[\mmaSqrt{x}==y,x]}
}


\cleardoublepage